const { isFunction, isGenerator } = require("./utilities.js");

const TASK = Symbol("task");
const CATCHER = Symbol("catcher");
const FINALIZER = Symbol("finally");

/**
 *
 *
 * @param task The generator function to execute
 */
function perform(task) {

	if (!isGenerator(task)) {
		throw TypeError(`${task} is not a generator function`)
	}

	// create an object that is prototype linked with the 'perform.prototype' object
	const _this = Object.create(perform.prototype);

	// store the generator privately inside that object
	_this[TASK] = task;

	// return that object
	return _this;
}

// the objects generated by 'perform' will have only one method: the 'catch' method
// this avoid weird 'finally' or 'try' calls without a proper 'catch' call

// do you know about hoisting? :P
perform.prototype.catch = _catch;

/**
 *
 *
 * @param catcher The function responsible of handling errors
 * @returns An object that let you start the computation or add a finalizer function
 */
function _catch(catcher) {

	if (!isFunction(catcher)) {
		throw TypeError(`${task} is not a generator function`)
	}

	// store the catcher fn privately
	this[CATCHER] = catcher;

	// when the 'try' method is invoked, the generator must start
	const tryFn = () => run.call(this);

	// this avoid weird 'finally' or 'try' calls without a proper 'catch' call
	// and avoid subsequents 'catch' calls
	return {

		finally: finalizer => {

			if (!isFunction(finalizer)) {
				throw TypeError(`${finalizer} is not a generator function`)
			}

			// store the finalizer fn privately
			this[FINALIZER] = finalizer;

			// after callinf the 'finally' method we can only start the generator
			return {
				try: tryFn
			}
		},

		// calling the 'finally' method is not mandatory, the  generator could be started without it
		try: tryFn
	}
}

/**
 *
 * @param this Always an object created by perform->catch || perform->catch->finally chains
 * *
 */
function run() {

	// start the majestic generator
	const it = this[TASK]();

	// it will store the IteratorResult
	let next;
	// it will store value contained into the IteratorResult or the value inserted with 'recoverFn'
	let value;

	// some bool-ish flags to make my life easier
	let recover = false;
	let restart = false;

	// nop
	const nop = () => { };
	// this function could be be called when an error has occurred inside a yielded computation
	// to recover the main task (the generator)
	const recoverFn = v => (value = v, recover = true);
	// this function could be called after any error to restart the main task (the generator)
	const restartFn = () => (restart = true);

	// the rare do-while loop
	do {
		try {
			// we feed the generator with the last IteratorResult value
			// at the first iteration, 'value' will be undefined but generators do ignore
			// the first inserted value
			next = it.next(value);
		} catch (error) {
			// if an error has occurred during the n-th iteration of the
			// generator, it means that the error was not thrown from a yielded computation,
			// but from the generator itself
			// So the current instance of the generator is no more usable, we can only restart it
			this[CATCHER](
				{ error, isRecoverable: false },
				nop,
				restartFn
			);

			if (restart) {
				return run.call(this); // loving TCO
			}

			// if the 'restartFn' was not called, it means that the generator should not be restarted
			// we cannot do anything except call the 'finalizer' function
			this[FINALIZER] && this[FINALIZER]();
			return;
		}

		// if no errors have occurred during the n-th iteration of the generator,
		// something was yielded out
		// usually it should be a delayed computation, but...
		const expr = isFunction(next.value) ? next.value : (() => next.value);

		try {
			// evaluate the delayed expression
			// if everything went well this value will be inserted into
			// the generators during the next iteration
			value = expr();
		} catch (error) {
			// what about errors inside yielded computations?
			// them will be recoverable, because thanks to the 'yield' keyword we can insert
			// a rescue value inside the generator in their place
			this[CATCHER](
				{ error, isRecoverable: true },
				recoverFn,
				restartFn
			);

			// if we want we can restart the whole generator
			if (restart) {
				return run.call(this);
			}

			// or we can recover from the error
			// remember that the 'recoverFn' will set the 'value' to be inserted inside the generator
			// into the next iteration
			if (recover) {
				recover = false;
				continue;
			}

			// if the 'restartFn' and the 'recoverFn' were not called, it means that the generator
			// should not be recovered nor restarted: we cannot do anything except call the 'finalizer' function
			this[FINALIZER] && this[FINALIZER]();
			return;
		}
	} while (!next.done);


	// also when the generator ends successfully we should call the 'finalizer'
	this[FINALIZER] && this[FINALIZER]();
	return;

}

// hi module.exports :D
// hoping you're doing well
module.exports.perform = perform;


